/**
 * Created by Hroniko on 13.10.2016.
 */
// Класс бинарного АВР-дерева
public class Tree <T extends  Comparable> { // Делаем через дженерики для более обобщенного вида класса
    // Поля класса:
    public T key; // Ключ узла
    public int height; // Высота узла
    // public String info; // Информационное поле, пока не используется
    // public double element; // Вещественное значение, пока не используется
    public Tree left; // Левый потомок (ссылка на объект класса Дерево)
    public Tree right; // Правый потомок (ссылка на объект класса Дерево)

    // Методы классса:

    // Метод поиска узла по его индексу в дереве, начинающемуся с данного корня root:
    private Tree<T> findNode(Tree<T> root, T x){
        if (root == null){ // Если больше нет элементов,
            return null; // возвращем пустую ссылке
        }
        if (root.key == x){ // Если ключи совпали,
            return root; // возвращаем ссылку на текущий элемент
        }
        if (root.key.compareTo(x) == 1){ // Если ключ орневого элемента больше искомого, то
            return findNode(root.left, x); // "сворачиваем" налево, то есть идем и ищем в левом потомке
        }
        else {
            return findNode(root.right, x); // Иначе идем и ищем в правом потомке
        }
    }
    // Метод поиска узла по его индексу в дереве, автоматически подхватывает сслку объекта на самого себя и передает в перегруженный метод выше:
    public Tree<T> findNode(T x){
        return findNode(this, x);
    }

    // -----------------------------------------------------------------------------
    // ПРЯМОЙ ОБХОД
    // Прямой порядок обхода (FrontOrder, DirectOrder, TopDownOrder, сверху вниз)
    // заключается в том, что корень некоторого дерева посещается раньше,
    // чем его поддеревья. Если после корня посещается его левое (правое)
    // поддерево, то обход называется прямым левым (правым) обходом.

    // 1) Метод прямого левого обхода с выводом ключей на консоль:
    public void frontOrderLeft(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        System.out.print(v.key + " "); // Напечатать значение ключа
        frontOrderLeft(v.left); // И идем в левую ветку
        frontOrderLeft(v.right); // И затем в правую ветку
    }
    // 1.1) Метод прямого левого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void frontOrderLeft(){
        frontOrderLeft(this);
    }

    // 2) Метод прямого правого обхода с выводом ключей на консоль:
    public void frontOrderRight(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        System.out.print(v.key + " "); // Напечатать значение ключа
        frontOrderRight(v.right); // И идем в правую ветку
        frontOrderRight(v.left); // И затем в левую ветку
    }
    // 2.1) Метод прямого правого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void frontOrderRight(){
        frontOrderRight(this);
    }

    // -----------------------------------------------------------------------------
    // ОБРАТНЫЙ ОБХОД
    // Обратный порядок обхода (BackOrder, DownTopOrder, снизу вверх)
    // заключается в том, что корень дерева посещается после его поддеревьев.
    // Если сначала посещается левое (правое) поддерево корня,
    // то обход называется обратным левым (правым) обходом.

    // 3) Метод обратного левого обхода с выводом ключей на консоль:
    public void backOrderLeft(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        backOrderLeft(v.left); // И идем в левую ветку
        backOrderLeft(v.right); // И затем в правую ветку
        System.out.print(v.key + " "); // Напечатать значение ключа
    }
    // 3.1) Метод прямого левого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void backOrderLeft(){
        frontOrderLeft(this);
    }

    // 2) Метод прямого правого обхода с выводом ключей на консоль:
    public void frontOrderRight(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        System.out.print(v.key + " "); // Напечатать значение ключа
        frontOrderRight(v.right); // И идем в правую ветку
        frontOrderRight(v.left); // И затем в левую ветку
    }
    // 2.1) Метод прямого правого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void frontOrderRight(){
        frontOrderRight(this);
    }



}
