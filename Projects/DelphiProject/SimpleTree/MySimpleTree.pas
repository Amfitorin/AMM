// Модуль реализации постых деревьев
unit MySimpleTree;

interface  // Раздел описаний

uses SysUtils,
    MySimpleSort;  // Подключаем модель с реализацией сортировок
    
// Описание типа - структура бинарного дерева на указателях:
// Представление в виде списковой структуры:
type
  tree_ptr = ^ tree_node;
  tree_node = record
     key: Integer;    // Ключ узла
     height: Integer; // Высота узла (расстояние в дугах от узла до наиболее удаленного потомка)
     depth: Integer; // Глубина узла (расстояние в дугах от корня до узла)
     weight: Integer; // Смещение влево-вправо относительно корневого элемента (по горизонтали)
     //info: string;  // Информационное поле, пока не используется
     //element: Real; // Вещественное значение, пока не используется
     left: tree_ptr; // Левый потомок (указатель)
     right: tree_ptr; // Правый потомок (указатель)
  end;

type
  Mass = array of Integer;

procedure FrontOrderLeft(v: tree_ptr);  // 1) Процедура прямого левого обхода с выводом на консоль
procedure FrontOrderLeftPosition(v: tree_ptr);
procedure FrontOrderRight(v: tree_ptr); // 2) Процедура прямого правого обхода с выводом на консоль
procedure BackOrderLeft(v: tree_ptr);   // 3) Процедура обратного левого обхода с выводом на консоль
procedure BackOrderRight(v: tree_ptr);  // 4) Процедура обратного правого обхода с выводом на консоль
procedure InnerOrderLeft(v: tree_ptr);  // 5) Процедура левого внутреннего обхода с выводом на консоль
procedure InnerOrderRight(v: tree_ptr); // 6) Процедура правого внутреннего обхода с выводом на консоль

//
procedure PrintTree(t: tree_ptr; h: Integer); // 9) Процедура печати дерева с h отступами
function HeightNode(t: tree_ptr): Integer;    // 10) Функция возврата высоты узла
function BalanceFactorNode(p: tree_ptr): Integer; // 11) Процедура для вычисляния balance factor заданного узла
procedure FixHeight(p: tree_ptr); // 12) Процедура восстановления корректного значения поля height
//procedure FixDepthNode(p: tree_ptr; rootHeight: Integer); // 13) Процедура восстановления корректного значения поля depth заданного узла
//procedure FixDepthTree(p: tree_ptr); // 14) Процедура восстановления корректного значения поля depth всех узлов



// 16) Функция вставки ключа k в дерево с корнем p:
function InsertKey(p: tree_ptr; k: Integer): tree_ptr;
// 16) Функция вставки ключа k в дерево с корнем p:
procedure BalancedDepth(v: tree_ptr; d: Integer; w: Integer);
//
// 17) Вспомогательная функция поиска узла с минимальным ключем в дереве p
function FindMinNode(p: tree_ptr): tree_ptr;
// 17) Вспомогательная функция поиска узла с минимальным ключем в дереве p
function FindMaxNode(p: tree_ptr): tree_ptr;
// 16) Процедура НОРМАЛЬНОЙ печати дерева
procedure NormPrintTree(p: tree_ptr);
// 1) Процедура прямого левого обхода с выводом на консоль
procedure FrontOrderLeftToMatrix(v: tree_ptr);

//
function RemoveMinNode(p: tree_ptr): tree_ptr; // 18) Cлужебная функция для удаления минимального элемента из заданного дерева:
function RemoveKey(p: tree_ptr; k: Integer): tree_ptr; // 19) Собственно, сама функция удаления элемента по его ключу // удаление ключа k из дерева p
//
function ParentCount(v: tree_ptr): Integer;
procedure CopyLR(v: tree_ptr; var arr : Mass);
function CopyLRtoMassiv(v: tree_ptr): Mass;
function CountLR(v: tree_ptr): Integer;
procedure LR(v: tree_ptr);
procedure PrintArr(arr: Mass);

var i: Integer;
    massiv: array of Integer;
    masPlot: array of Char;
    msv: array of array of String;  // Динамический двумерный массив на делфи
    

implementation
// ---- Раздел реализаций ---

// -----------------------------------------------------------------------------
// ПРЯМОЙ ОБХОД
// Прямой порядок обхода (FrontOrder, DirectOrder, TopDownOrder, сверху вниз)
// заключается в том, что корень некоторого дерева посещается раньше,
// чем его поддеревья. Если после корня посещается его левое (правое)
// поддерево, то обход называется прямым левым (правым) обходом.

// 1) Процедура прямого левого обхода с выводом на консоль
procedure FrontOrderLeft(v: tree_ptr);
begin
  if v <> nil then
  begin
    Write(v^.key, ' '); // Напечатать значение ключа
    FrontOrderLeft(v^.left);
    FrontOrderLeft(v^.right);
  end;
end;
// 1.1) Процедура прямого левого обхода с выводом на консоль (с выводом позиции)
procedure FrontOrderLeftPosition(v: tree_ptr);
begin
  if v <> nil then
  begin
    Write(v^.key, '[', v^.weight, ',', v^.depth, '] '); // Напечатать значение ключа
    FrontOrderLeftPosition(v^.left);
    FrontOrderLeftPosition(v^.right);
  end;
end;

// 2) Процедура прямого правого обхода с выводом на консоль
procedure FrontOrderRight(v: tree_ptr);
begin
  if v <> nil then
  begin
    Write(v^.key, ' '); // Напечатать значение ключа
    FrontOrderRight(v^.right);
    FrontOrderRight(v^.left);
  end;
end;

// -----------------------------------------------------------------------------
// ОБРАТНЫЙ ОБХОД
// Обратный порядок обхода (BackOrder, DownTopOrder, снизу вверх)
// заключается в том, что корень дерева посещается после его поддеревьев.
// Если сначала посещается левое (правое) поддерево корня,
// то обход называется обратным левым (правым) обходом.

// 3) Процедура обратного левого обхода с выводом на консоль
procedure BackOrderLeft(v: tree_ptr);
begin
  if v <> nil then
  begin
    BackOrderLeft(v^.left);
    BackOrderLeft(v^.right);
    Write(v^.key, ' '); // Напечатать значение ключа
  end;
end;

// 4) Процедура обратного правого обхода с выводом на консоль
procedure BackOrderRight(v: tree_ptr);
begin
  if v <> nil then
  begin
    BackOrderRight(v^.right);
    BackOrderRight(v^.left);
    Write(v^.key, ' '); // Напечатать значение ключа
  end;
end;

// -----------------------------------------------------------------------------
// ВНУТРЕННИЙ ОБХОД
// Внутренний порядок обхода (InnnerOrder, слева направо или справа налево)
// заключается в том, что корень посещается после посещения одного из его
// поддеревьев. Если корень посещается после посещения его левого (правого)
// поддерева, то обход называется внутренним левым (правым) обходом. Заметим,
// что внутренний левый (правый) обход посещает вершины дерева в порядке
// возрастания (убывания) ключей вершин.

// 5) Процедура левого внутреннего обхода с выводом на консоль
procedure InnerOrderLeft(v: tree_ptr);
begin 
  if v <> nil then
  begin
    InnerOrderLeft(v^.left);
    Write(v^.key, ' '); // Напечатать значение ключа
    InnerOrderLeft(v^.right);
  end;
end;

// 6) Процедура правого внутреннего обхода с выводом на консоль
procedure InnerOrderRight(v: tree_ptr);
begin
  if v <> nil then
  begin
    InnerOrderRight(v^.right);
    Write(v^.key, ' ');
    InnerOrderRight(v^.left);
  end;
end;

// -----------------------------------------------------------------------------
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// (придуманы в 1962 году советскими учеными Адельсон-Вельским и Ландисом)

// 9) Процедура печати дерева с h отступами
procedure PrintTree(t: tree_ptr; h: Integer);
var j: Integer;
begin
  if t <> nil then
  begin
    PrintTree(t^.left, h+1);
    for j:= 0 to h do Write(#9); // Знак табуляции
    Writeln(t^.key);
    Writeln;
    PrintTree(t^.right, h+1);
  end;
end;




// -----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ РЕАЛИЗАЦИИ АВЛ-ДЕРЕВЬЕВ, ВСТАВКА ЭЛЕМЕНТА
// (придуманы в 1962 году советскими учеными Адельсон-Вельским и Ландисом)

// 10) Функция возврата высоты узла:
function HeightNode(t: tree_ptr): Integer;
begin
  if t <> nil then
  HeightNode:= t^.height
  else HeightNode:= 0;
end;

// 11) Процедура для вычисляния balance factor заданного узла (работает только с ненулевыми указателями):
function BalanceFactorNode(p: tree_ptr): Integer;
begin
  BalanceFactorNode:= HeightNode(p^.right) - HeightNode(p^.left);
end;

// 12) Процедура восстановления корректного значения поля height заданного узла
//(при условии, что значения этого поля в правом и левом дочерних узлах являются
// корректными):
procedure FixHeight(p: tree_ptr);
var hL, hR: Integer;
begin
  hL:= HeightNode(p^.left);
  hR:= HeightNode(p^.right);
  if hL > hR then p^.height:= hL + 1
  else p^.height:= hR + 1;
end;
//// 13) Процедура восстановления корректного значения поля depth заданного узла
//procedure FixDepthNode(p: tree_ptr; rootHeight: Integer);
//begin
//  if p <> nil then
//  begin
//    p^.depth:= rootHeight - p^.height; //
//    FixDepthNode(p^.left, rootHeight);
//    FixDepthNode(p^.right, rootHeight);
//  end;
//end;
//// 14) Процедура восстановления корректного значения поля depth всех узлов
//procedure FixDepthTree(p: tree_ptr);
//begin
//  FixDepthNode(p, p^.height);
//end;  

// Балансировка узлов
// В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение
// ситуации, когда balance factor некоторых узлов оказывается равными 2 или -2,
// т.е. возникает расбалансировка поддерева. Для выправления ситуации
// применяются хорошо известные повороты вокруг тех или иных узлов дерева.

// 16) Функция вставки ключа k в дерево с корнем p:
function InsertKey(p: tree_ptr; k: Integer): tree_ptr;
begin
  if p = nil then
  begin
    New(p);
    p^.key:= k;
    p^.height:=0;
    p^.depth:= 0;
    p^.weight:= 0;
    p^.left:= nil;
    p^.right:= nil;
    BalancedDepth(p, 0, 0);
    Result:= p;
  end
  else
  begin
    if k < p^.key then p^.left:= InsertKey(p^.left, k)
    else p^.right:= InsertKey(p^.right, k);
    BalancedDepth(p, 0, 0);
    // Result:= BalanceNode(p);
    Result:= p;
  end;
end;

// 16) Функция пересчета глубины узлов:
procedure BalancedDepth(v: tree_ptr; d: Integer; w: Integer);
begin
  if v <> nil then
  begin
    v.depth:= d;
    v.weight:= w;
  end;
  if v^.left <> nil then
  begin
    BalancedDepth(v^.left, d+1, w-1);
  end;
  if v^.right <> nil then
  begin
    BalancedDepth(v^.right, d+1, w+1);
  end;
end;

// 17) Вспомогательная функция поиска узла с минимальным ключем в дереве p
function FindMinNode(p: tree_ptr): tree_ptr;
begin
  if p^.left <> nil then Result:= FindMinNode(p^.left)
  else Result:= p;
end;

// 17) Вспомогательная функция поиска узла с минимальным ключем в дереве p
function FindMaxNode(p: tree_ptr): tree_ptr;
begin
  if p^.right <> nil then Result:= FindMaxNode(p^.right)
  else Result:= p;
end;

// 16) Процедура НОРМАЛЬНОЙ печати дерева
procedure NormPrintTree(p: tree_ptr);
var sizeX, sizeY: Integer; // Размеры матрицы
    i, j, z: Integer;
begin
  if p <> nil then
  begin
    if p^.left <> nil then
    begin
      NormPrintTree(p^.left);
    end
    else
    begin
      write(p^.key);
    end;

    if p^.right <> nil then
    begin
      write('  ');
      NormPrintTree(p^.right);
    end
    else
    begin
      write('  ');
      Writeln(p^.key);
    end; 

  end;
end;  


// 1) Процедура прямого левого обхода с занесением в массив
procedure FrontOrderLeftToMatrix(v: tree_ptr);
begin
  if v <> nil then
  begin
    //Writeln((v^.depth));
    msv[v^.depth, v^.weight + Length(msv) - 1]:= IntToStr(v^.key);
    //Write(msv[(v^.weight + Length(msv)), (v^.depth)], ' '); // Напечатать значение ключа
    FrontOrderLeftToMatrix(v^.left);
    FrontOrderLeftToMatrix(v^.right);
  end;
end;



// -----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ РЕАЛИЗАЦИИ ДЕРЕВЬЕВ, УДАЛЕНИЕ ЭЛЕМЕНТА



// 18) Cлужебная функция для удаления минимального элемента из заданного дерева:
function RemoveMinNode(p: tree_ptr): tree_ptr;
begin
  if (p^.left = nil) then Result:= p^.right
  else
  begin
    p^.left:= RemoveMinNode(p^.left);
    // Result:= BalanceNode(p);
    Result:= p;
  end;
end;  

// 19) Собственно, сама функция удаления элемента по его ключу:
function RemoveKey(p: tree_ptr; k: Integer): tree_ptr; // удаление ключа k из дерева p
var q, r, min: tree_ptr;
begin
  if p = nil then Result:= nil
  else
  begin
    if k < p^.key then p^.left:= RemoveKey(p^.left, k)
    else
      if k > p^.key then p^.right:= RemoveKey(p^.right, k)
      else  // Нашли ключ, т.е. k = p^.key
        begin
          // Writeln(p^.key); // 11 Для отладки
          q:= p^.left; // Запомнили левое поддерево   // 10
          r:=p^.right; // Запомнили правое поддерево  // 13
          if r = nil then p:= q   // Если правого поддререва нет, просто переносим на место строго узла новый
          else
          begin
            min:= FindMinNode(r); // иначе ищем минимальный элемент в правом поддереве и запоминаем его
            // Writeln(min^.key); // 12 Для отладки
            min^.right:= RemoveMinNode(r); // Перенесли в правой поддерево 12 элемента элемент 13 и всю его цепочку
            // Writeln((min^.right)^.key);  // Для отладки
            min^.left:= q;
            p:= min; // Вот этого не было
            Result:= p; //BalanceNode(min);
          end;  
        end;  
  end;
  // И если не пустой указатель, то балансируем узел, или просто возвращаем nil
  if p <> nil then Result:= p //BalanceNode(p)
  else Result:= nil;
end;  


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// ФУНКЦИИ ДЛЯ СОБСТВЕННО РЕШЕНИЯ ЗАДАЧИ

// 20) Рекурсивная функция подсчета количества наследников у узла
function ParentCount(v: tree_ptr): Integer;
begin
  if v <> nil then
  Result:= 1 + ParentCount(v^.left) + ParentCount(v^.right)
  else Result:= 0;
end;

// 21) Процедура поиска и копирования в массив ключей тех узлов, у которых количество
// потомков в левом поддереве отличается от количества потомков в правом
// поддереве на 1
// Передаем указатель на дерево, ссылку на массив и номер элемента
procedure CopyLR(v: tree_ptr; var arr : Mass);
begin
  if v <> nil then
  begin
    if Abs( ParentCount(v^.left) - ParentCount(v^.right) ) = 1 then
    begin
      i:= i + 1;
      arr[i]:= v^.key; // Скопировать значение ключа
      // Writeln(arr[i]);
    end;
    CopyLR(v^.left, arr);
    CopyLR(v^.right, arr);
  end;
end;

// Функция копирования в массив
function CopyLRtoMassiv(v: tree_ptr): Mass;
var size : Integer;
    arr : Mass;
begin
  if v <> nil then
  begin
    // Определяем количество элементов, чтобы знать, какого размера создать массив:
    size:= CountLR(v);
    SetLength(arr, size);  // Выставляем длину одномерного массива
    i:= -1;
    CopyLR(v, arr); // Выполняем копирование подходящих значений в массив
    Result:= arr;
  end
  else Result:= nil;
end;

// 22) Функция подсчета количества узлов, у которых количество
// потомков в левом поддереве отличается от количества потомков в правом
// поддереве на 1
function CountLR(v: tree_ptr): Integer;
begin
  if v <> nil then
  begin
    if Abs( ParentCount(v^.left) - ParentCount(v^.right) ) = 1 then
    begin
      Result:= 1 + CountLR(v^.left) + CountLR(v^.right);
    end
    else Result:= CountLR(v^.left) + CountLR(v^.right);
  end
  else Result:=0;
end;

// Процедура находжения и удаления (правым удалением) среднюю по значению
// вершину из вершин дерева, у которых количество потомков в левом поддереве
// отличается от количества потомков в правом поддереве на 1

procedure LR(v: tree_ptr);
var arr: Mass;
    n: Integer; // Количество элементов
    key: Integer; // Найденный ключ средней по значению вершины
begin
  // Определяем количество подходящих элементов:
  n:= CountLR(v);
  //Writeln(n);
  if n = 0 then
    Writeln('Подходящих узлов не найдено. Завершение программы')
  else
  begin
    arr:= CopyLRtoMassiv(v); // Иначе все хорошо, переносим все подходящие элементы в массив
    QuickSortNonRecursive(arr); // Сортируем массив
    PrintArr(arr); // Печатаем все элементы массива

    if (n mod 2) = 0 then
    begin
      Writeln('Подходящих элементов четное количество (', n, ')');
      Writeln('Нет медианы среди найденных узлов. Завершение программы');
    end
    else
    begin
      Writeln('Подходящих элементов нечетное количество (', n, ')');
      Writeln('Средняя по значению вершина: ', arr[(n mod 2)]);



      
    end;
  end;
end;

procedure PrintArr(arr: Mass);
var j: Integer;
begin
  write('Подходящие элементы: ');
  for j:= 0 to Length(arr)-1 do
  begin
    write(arr[j], ' ');
  end;
  Writeln;
end;



end.
